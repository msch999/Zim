<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>EmitterHitter</title>

  <script src="https://d309knd7es5f10.cloudfront.net/createjs_1.1_min.js"></script>
  <script src="https://d309knd7es5f10.cloudfront.net/zim_10.4.1.js"></script>
  <!-- use zimjs.com/distill for minified individual functions! -->

  <script>
    var assets = ["C_D_E_D.001.mp3"]; // sound or image assets to be loaded
    var path = "assets/";

    var frame = //new Frame(scaling, width, height, color, outerColor);
      new Frame("fit",
        window.screen.availWidth,
        window.screen.availHeight,
        "#000", "#555", assets, path);

    frame.on("ready", function() {
      var stage = frame.stage;
      var stageW = frame.width;
      var stageH = frame.height;
      // put your code here
      //localStorage.clear(); // uncomment to reset localStorage
      var data; // will hold all the data for the scores, sizes, max and circles
      if (localStorage && localStorage.game) {
        // 2. if there is localStorage data then set the data to the localStorage data
        data = JSON.parse(localStorage.game);
      } else {
        // 3. if there is not localStorage data then set the data to starting values
        data = {
          score: 0,
          high: 0,
          // particle parameters
          partNum: 1,
          partForce: 0.3,
          partSinkForce: 0.3,
          partInterval: 500,
          partLife: 8000,
          // level parameters
          maxTimeInLevel: 5,
          curLevel: 0,
          godMode: false
        };
      }

//      var

      // define save function for data
      function saveTolocalStorage() {
        //        data.score = Math.round(s);
        //        data.circles.push([Math.round(circle.x), Math.round(circle.y), circle.width, circle.color, circle.borderColor, a]);
        // {score:20, high:30, lastSize:44, lastMax:55, circles:[[x,y,d,color,stroke,alpha], [x,y,r,color,stroke,alpha], etc.]}
        // read in default data, from stored or initialized data
        data.score = score;
        data.high = high;
        data.partNum = partNum;
        data.partForce = partForce;
        data.partSinkForce = partSinkForce;
        data.partInterval = partInterval;
        data.partLife = partLife;
        // level parameters
        data.maxTimeInLevel = maxTimeInLevel;
        data.godMode = godMode;
        //data.curLevel = 0;

        localStorage.game = JSON.stringify(data);

      }

      // read in default data, from stored or initialized data
      var score = data.score;
      var high = data.high;

      // particle parameters
      var partNum = data.partNum;
      var partForce = data.partForce;
      var partSinkForce = data.partSinkForce;
      var partInterval = data.partInterval;
      var partLife = data.partLife;
      // level parameters
      var maxTimeInLevel = data.maxTimeInLevel;
      var godMode = data.godMode;
      var curLevel = 0; //init level not read in

      var levelLabel; //msg label in panel
      var countdownLabel;
      var stepperPartNum = null;
      var stepperPartForce = null;
      var stepperPartSinkForce = null;
      var stepperPartInterval = null;
      var stepperPartLife = null;
      var stepperMaxTimeInLevel = null;

      var backgroundCircleBelow = new Circle(stageH / 2 + 70, "#111111").centerReg(stage);
      var backgroundCircleTop = new Circle(stageH / 2 - 50, "#333333").centerReg(stage);
      var theCenter = new Circle(10, orange).centerReg(stage);

      var circle; // attracts the particles and is draggable
      var particles; // the Emitter

      var countDownTimer = maxTimeInLevel;
      var countingTime = true;
      //
      var theNewEmitterParticle = new Label({
        text: "‚≠ê",
        size: 40,
        align: "center"
      });

      // counting down from maxTimeInLevel to 0, then inc level
      // repeat after a second = 1000 ms
      var iv = interval(1000, function() {
        if (countingTime == true) {
          if (countDownTimer > 0) {
            countDownTimer--;
            countdownLabel.text = "Time: " + countDownTimer
          } else {
            // timer is now 0; remove emitter
            particles.particles.removeFrom(stage);

            curLevel++;
            //reset timer
            countDownTimer = maxTimeInLevel;

            countdownLabel.text = "Time: " + countDownTimer
            levelLabel.text = "Current Level: " + curLevel.toString().padStart(2, '0');

            // display new emitter params on steppers
            //partNum++;

            stepperPartNum.currentVal = partNum;
            stepperPartForce.currentValue = partForce;
            stepperPartSinkForce.currentValue = partSinkForce;
            stepperPartInterval.currentValue = partInterval;
            stepperPartLife.currentValue = partLife;
            stepperMaxTimeInLevel.currentValue = maxTimeInLevel;

            theNewEmitterParticle = new Label({
              text: theNewEmitterParticle.label.text,
              size: 40,
              align: "center"
            });

            //zog(theNewEmitterParticle.label.text);

            setUpEmitter();
          }
        }
      });


      function setupPlayerToken() {
        // random x y
        var startPosx = zim.rand(50, stageW - 50);
        var startPosy = zim.rand(50, stageH - 50);
        //var circle = new Circle(10, "#7FFF00").addTo(stage).pos(startPosx, startPosy).drag();
        circle = new Label({
            text: "üêÑ",
            size: 40,
            align: "center"
          })
          .addTo(stage)
          .centerReg(null, null, false)
          .pos(startPosx, startPosy)
          .animate({
            obj: {
              alpha: 0,
              rotation: [-360, 360]
            },
            time: 2000,
            from: true
          })
          .drag();
      } // end of setupPlayerToken

      function setUpEmitter() {
        particles = new zim.Emitter({
          // obj: [new Circle(20, null, [darker, lighter], 2),
          //   new Rectangle(30, 30, null, [darker, lighter], 2),
          ////   new Triangle(40, 40, 40, null, [darker, lighter], 2)
          obj: theNewEmitterParticle,
          random: {
            //          color: colorPal_Gold,
            rotation: {
              min: -360,
              max: 360
            },
            scale: {
              min: 0.4,
              max: 1.0
            }
          },
          interval: partInterval,
          num: partNum,
          life: partLife,
          fade: false,
          shrink: false,
          force: partForce,
          gravity: 0,
          animation: {
            obj: {
              rotation: ["360", "-360"]
              //, scale: 0.7
            },
            loop: true,
            time: {
              min: 4000,
              max: 5000
            },
            ease: "linear",
            from: false
          },
          sink: circle,
          sinkForce: partSinkForce,
          startPaused: false
        }).centerReg(stage);
      } // end of setUpEmitter


      function setUpUi() {

        // panel hosts two data tabs: dataTab1, dataTab2 definded below
        var panel = new Panel({
          width: 400,
          height: 300,
          titleBar: series("data page 1", "data page 2"),
          draggable: true
        });

        // content for panel 1
        var dataTab1 = new Container(panel.width, panel.height);
        var col1X = 15;
        var col1Y = 50;
        // -------------------------------------------------------------------
        stepperPartNum = new Stepper({
            continuous: false,
            stepperType: "number",
            min: 0,
            max: 1000
          })
          .pos(col1X, col1Y, false, false, dataTab1).sca(.25);
        stepperPartNum.currentValue = partNum;
        stepperPartNum.on("change", function() {
          partNum = stepperPartNum.currentValue;
          stage.update();
        });
        new Label({
          text: "partNum",
          size: 17,
          color: black,
          align: "left"
        }).addTo(dataTab1).pos(col1X + 110, col1Y + 3);
        // -------------------------------------------------------------------
        stepperPartForce = new Stepper({
            continuous: false,
            stepperType: "number",
            min: 0,
            max: 20,
            step: 0.10
          })
          .pos(col1X, col1Y + 35, false, false, dataTab1).sca(.25);
        //stepperPartForce.currentValue = Number.parseFloat(partForce).toFixed(2);
        stepperPartForce.currentValue = partForce;
        stepperPartForce.on("change", function() {
          partForce = stepperPartForce.currentValue;
          stage.update();
        });
        new Label({
          text: "partForce",
          size: 17,
          color: black,
          align: "left"
        }).addTo(dataTab1).pos(col1X + 110, col1Y + 35 + 3);
        // -------------------------------------------------------------------
        // var partSinkForce = 0.3;
        stepperPartSinkForce = new Stepper({
            continuous: false,
            stepperType: "number",
            min: 0.00,
            max: 20.00,
            step: 0.10
          })
          .pos(col1X, col1Y + 35 + 35, false, false, dataTab1).sca(.25);
        stepperPartSinkForce.currentValue = Number.parseFloat(partSinkForce).toFixed(2);
        stepperPartSinkForce.on("change", function() {
          partSinkForce = stepperPartSinkForce.currentValue;
          stage.update();
        });
        new Label({
          text: "partSinkForce",
          size: 17,
          color: black,
          align: "left"
        }).addTo(dataTab1).pos(col1X + 110, col1Y + 35 + 35 + 3);
        // -------------------------------------------------------------------
        // var partInterval = 500;
        stepperPartInterval = new Stepper({
            continuous: false,
            stepperType: "number",
            min: 0,
            max: 10000,
            step: 50
          })
          .pos(col1X, col1Y + 35 + 35 + 35, false, false, dataTab1).sca(.25);
        stepperPartInterval.currentValue = partInterval;
        stepperPartInterval.on("change", function() {
          partInterval = stepperPartInterval.currentValue;
          stage.update();
        });
        new Label({
          text: "partInterval",
          size: 17,
          color: black,
          align: "left"
        }).addTo(dataTab1).pos(col1X + 110, col1Y + 35 + 35 + 35 + 3);
        // -------------------------------------------------------------------
        // var partLife = 8000;
        stepperPartLife = new Stepper({
            continuous: false,
            stepperType: "number",
            min: 0,
            max: 20000,
            step: 500
          })
          .pos(col1X, col1Y + 35 + 35 + 35 + 35, false, false, dataTab1).sca(.25);
        stepperPartLife.currentValue = partLife;
        stepperPartLife.on("change", function() {
          partLife = stepperPartLife.currentValue;
          stage.update();
        });
        new Label({
          text: "partLife",
          size: 17,
          color: black,
          align: "left"
        }).addTo(dataTab1).pos(col1X + 110, col1Y + 35 + 35 + 35 + 35 + 3);
        // -------------------------------------------------------------------
        // var maxTimeInLevel = 15;
        stepperMaxTimeInLevel = new Stepper({
            continuous: false,
            stepperType: "number",
            min: 0,
            max: 1000,
            step: 1
          })
          .pos(col1X, col1Y + 35 + 35 + 35 + 35 + 35, false, false, dataTab1).sca(.25);
        stepperMaxTimeInLevel.currentValue = maxTimeInLevel;
        stepperMaxTimeInLevel.on("change", function() {
          maxTimeInLevel = stepperMaxTimeInLevel.currentValue;
          stage.update();
        });
        new Label({
          text: "max Time in Level",
          size: 17,
          color: black,
          align: "left"
        }).addTo(dataTab1).pos(col1X + 110, col1Y + 35 + 35 + 35 + 35 + 35 + 3);
        // -------------------------------------------------------------------
        var checkBox = new CheckBox({
            label: "god mode",
            size: 90,
            startChecked: godMode
          })
          .sca(.25)
          .addTo(dataTab1).pos(col1X, col1Y + 35 + 35 + 35 + 35 + 35 + 35);
        checkBox.on("change", function() {
          if (checkBox.checked) {
            godMode = true;
          } else {
            godMode = false;
          }
        });

        levelLabel = new Label({
            //            text: "Current Level: " + curLevel.toString().padStart(2, '0'),
            text: "Current Level: " + curLevel,
            size: 16,
            color: black,
            align: "left"
          })
          .addTo(dataTab1)
          .pos(250, col1Y);

        countdownLabel = new Label({
            text: "Time: " + countDownTimer,
            size: 16,
            color: black,
            align: "left"
          })
          .addTo(dataTab1)
          .pos(250, col1Y + 35);


        // content for panel 2
        var dataTab2 = new Container(panel.width, panel.height).center(panel); // initial adding to panel makes this the default

        var utf8Arr = ["\u{1F4A9}", "üò≤", "‚≠ê", "\u{1F600}", "‚ôªÔ∏è", "‚åö", "‚åõ", "‚ôæÔ∏è", "‚åõ", "‚ìÇÔ∏è", "‚ö™", "‚ö´", "‚õèÔ∏è", "‚õëÔ∏è", "‚ú®", "‚ùì", "„ÄΩÔ∏è", "üçæ", "ü•ê", "ü•û",
          "ü¶Ñ", "üßÄ", "üß¶", "‚õî", "‚õµ", "üèÜ", "üëÄ", "üïã", "üïé", "üíÉ", "üèÑ", "üö¥", "üõÄ", "üëØ", "üë£", "üë®", "üõ∂", "üå≥", "ü§©", "üòç", "üòµ", "üëª", "üíã", "üí£", "", ""
        ];

        var list = new List({
            list: utf8Arr,
            viewNum: 3, // this number will change the size of the list elements (default is 5)
            width: 80,
            scrollBarActive: true

          }).addTo(dataTab2).pos(col1X, col1Y)
          .on("click", function(e) {
            theNewEmitterParticle.label.text = e.target.text;
          });
        // .change(function(e) {
        //     theNewEmitterParticle.label.text = e.target.text;
        // });

        // var button = new Button({
        //   label: "STOP",
        //   toggle: "START"
        //   //        }).addTo(dataTab2).pos(50, 100);
        // }).addTo(dataTab2).pos(100, panel.height - 100);
        //
        // button.on("click", function() {
        //   if (countDownTimer != 0) {
        //     iv.pause(button.toggled);
        //   } else {
        //     //countDownTimer = 10;
        //   }
        //   var sound = frame.asset("C_D_E_D.001.mp3").play({
        //     interrupt: "any",
        //     volume: 0.2,
        //     loop: 0,
        //     pan: 0
        //   });
        //   //particles.pauseEmitter(button.toggled, freeze = true, immediate = true);
        // });

        // event to change content as panels change
        panel.on("change", function() {
          if (dataTab2.parent) {
            dataTab2.removeFrom();
            dataTab1.center(panel);
          } else {
            dataTab1.removeFrom();
            dataTab2.center(panel);
          }
        });

        panel.addTo().pos(50, 50);
        // var win = new Window({
        //   width: 800,
        //   height: 600,
        //   interactive: false,
        //   padding: 0,
        //   slideDamp: .2
        // });
        // win.add(panel); // add the content to the window
        // win.center(stage);

      } // end of setUpUi()

      setupPlayerToken();
      setUpEmitter();
      setUpUi();

      var tickerFunction = Ticker.add(function() {
        var p = particles.particles.children; // p is the array of individual Particles
        var numElem = p.length;
        var index = null; // for return value of hit test
        var wasHit = false;
        var cc = 0;

        // circle hit testing  the particles
        for (cc = 0; cc < numElem; cc++) {
          wasHit = circle.hitTestBounds(other = p[cc], margin = -10);
          if (wasHit && !godMode) {
            index = 0;
            break;
          }
        }

        if (index == 0) {
          //  circle is hit, stop the countdown
          countingTime = false;

          particles.pauseEmitter(true, freeze = true, immediate = true);

          saveTolocalStorage();

          // pulse the player token
          circle.animate({
            props: {
              scale: 1.5,
              rotation: -180
            },
            time: 300,
            ease: "linear",
            call: Ticker.remove(tickerFunction),
            loop: 0,
            rewind: false,
            from: false
          });

          // Check to see if a function is in the Ticker for that stage:
          zog(Ticker.has(tickerFunction)); // false at the moment until added again

        } else {
          // nothing was hit
        }
      }, stage); // end of tickerFunction()

      stage.update()
    }); // end of ready
  </script>
  <meta name="viewport" content="width=device-width, user-scalable=no" />
</head>

<body>
  <!-- canvas with id="myCanvas" is made by zim Frame -->
</body>

</html>
